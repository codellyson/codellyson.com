# Introduction

This post is going to take a good look at a different way to write an efficient react/nextjs app. this post will show how to not commit or stop commiting one of the deadly sins been commited in react applications. Prop Drilling.

## Definition of concepts

### Prop Drilling

Prop drilling (also called "threading") refers to the process you have to go through to get data to parts of the React Component tree. Let's look at a very simple example of a stateful component  
[https://kentcdodds.com/blog/prop-drilling](https://kentcdodds.com/blog/prop-drilling)

### React Context API

Context provides a way to pass data through the component tree without having to pass props down manually at every level.
[https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html)

```tsx
// using a basic authentication example

import React, { createContext, useContext, useState } from "react";

interface AuthContextProps {
  userName: string;
  isLoggedIn: boolean;
  setUserName: (name: string) => void;
  setIsLoggedIn: (isLoggedIn: boolean) => void;
}

const AuthContext = createContext<AuthContextProps | null>(null);

export const AuthProvider: React.FC = ({ children }) => {
  const [userName, setUserName] = useState("");
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  return (
    <AuthContext.Provider value={{ userName, isLoggedIn }}>
      {children}
    </AuthContext.Provider>
  );
};

// trying to be clever on the usage of the context

export const useAuthContext = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuthContext must be used within an AuthProvider");
  }
  return context;
};

// usage of the context
// login.tsx

export const Auth = () => {
  const { setIsLoggedIn, setUserName } = useAuthCtx();
  const [userName, _setUserName] = useState("");
  const handleSubmit = () => {
    setIsLoggedIn(true);
    setUserName("John Doe");
  };

  return (
    <AuthProvider>
      <form>
        <input
          placeholder="username"
          value={userName}
          onChange={(e) => _setUserName(e.target.value)}
        />
        <button>Log In</button>
      </form>
    </AuthProvider>
  );
};
```

Please note that the example above is a very basic example of how to use the context api in react. The context api is very powerful and can be used in a lot of ways to solve a lot of problems in react applications.
what we have done in the example above is to create a context that holds the authentication state of the application and then we created a provider that will wrap the application and then we created a custom hook that will be used to access the context in the application.

In the next example we will be exploring how to use the context api to solve the problem of prop drilling in react applications. and also how to connect zustand to the context api to create a more efficient way of managing state in react applications. but before we go into that let's take a look at zustand.



### Zustand

Zustand is a small, fast and scaleable bearbones state-management solution using react hooks that is based on the same idea as redux but with a much simpler api.
[https://zustand.docs.pmnd.rs/getting-started/introduction](https://zustand.docs.pmnd.rs/getting-started/introduction)

```tsx
import {create} from "zustand";

interface AuthState {
  userName: string;
  isLoggedIn: boolean;
  setUserName: (name: string) => void;
  setIsLoggedIn: (isLoggedIn: boolean) => void;
}

export const useAuthStore = create<AuthState>((set) => ({
  userName: "",
  isLoggedIn: false,
  setUserName: (name) => set({ userName: name }),
  setIsLoggedIn: (isLoggedIn) => set({ isLoggedIn }),
}));


// usage of the zustand store

export const Auth = () => {
  const { setIsLoggedIn, setUserName } = useAuthStore();
  const [userName, _setUserName] = useState("");
  const handleSubmit = () => {
    setIsLoggedIn(true);
    setUserName("John Doe");
  };

  return (
    <form>
      <input
        placeholder="username"
        value={userName}
        onChange={(e) => _setUserName(e.target.value)}
      />
      <button>Log In</button>
    </form>
  );
};

```

In the example above we have created a zustand store that holds the authentication state of the application and then we created a custom hook that will be used to access the store in the application. The zustand store is very powerful and can be used in a lot of ways to solve a lot of problems in react applications.

if we had stopped here we would have been able to solve the problem of prop drilling in react applications but we can do better by combining the context api and zustand to create a more efficient way of managing state in react applications.

### Combining Zustand and Context API

```tsx
import React, { createContext, useContext, useState } from "react";
import { create, useStore } from "zustand";

interface AuthState {
  userName: string;
  isLoggedIn: boolean;
  setUserName: (name: string) => void;
  setIsLoggedIn: (isLoggedIn: boolean) => void;
}

const AuthContext = createContext<AuthState | null>(null);

const AuthProvider = ({ children }) => {
  const authRef = useRef<any>()

  if (!authRef.current) {
    authRef.current = create<AuthState>((set) => ({
      userName: "",
      isLoggedIn: false,
      setUserName: (name) => set({ userName: name }),
      setIsLoggedIn: (isLoggedIn) => set({ isLoggedIn }),
    }));
  }

  return (
    //passing the zustand store to the context provider
    <AuthContext.Provider value={authRef.current}>
      {children}
    </AuthContext.Provider>
  );
};


export const useAuthCtx = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuthCtx must be used within an AuthProvider");
  }
  // using the zustand store in the context
  return useStore(context);
};
```

In the example above we have combined the context api and zustand to create a more efficient way of managing state in react applications. We created a context that holds the zustand store and then we created a provider that will wrap the application and then we created a custom hook that will be used to access the store in the application.
Now we can leverage `zustand/persist` to persist the state of the application and also access the state of the application from any part of the application without having to pass props down manually at every level. Let's see an example of how to persist the state of the application using the context api and zustand.

```tsx
import React, { createContext, useContext, useState } from "react";
import { create, useStore } from "zustand";
import { persist } from "zustand/middleware";

interface AuthState {
  userName: string;
  isLoggedIn: boolean;
  setUserName: (name: string) => void;
  setIsLoggedIn: (isLoggedIn: boolean) => void;
}

const AuthContext = createContext<AuthState | null>(null);

const AuthProvider = ({ children }) => {
  const authRef = useRef<any>()

  if (!authRef.current) {
    authRef.current = create<AuthState>(
      persist(
        (set) => ({
          userName: "",
          isLoggedIn: false,
          setUserName: (name) => set({ userName: name }),
          setIsLoggedIn: (isLoggedIn) => set({ isLoggedIn }),
        }),
        {
          name: "auth-storage",
          storage: createJSONStorage(() => sessionStorage) // or localStorage,
        }
      )
    );
  }

  return (
    <AuthContext.Provider value={authRef.current}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuthCtx = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuthCtx must be used within an AuthProvider");
  }
  return useStore(context);
};
```

We can use it in the application same way we used the previous examples. The only difference is that the state of the application will be persisted in the browser storage.

```tsx
export const Auth = () => {
  const { setIsLoggedIn, setUserName } = useAuthCtx();
  const [userName, _setUserName] = useState("");
  const handleSubmit = () => {
    setIsLoggedIn(true);
    setUserName("John Doe");
  };

  return (
    <form>
      <input
        placeholder="username"
        value={userName}
        onChange={(e) => _setUserName(e.target.value)}
      />
      <button>Log In</button>
    </form>
  );
};
```
